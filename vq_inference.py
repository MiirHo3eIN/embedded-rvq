import matplotlib.pyplot as plt

import torch
from torch import nn, einsum
import torch.nn.functional as F

import seaborn as sns
from einops import rearrange, repeat, reduce, pack, unpack
import numpy as np

import argparse
parser_help = r"""
    The implemented tests are: 
        - vector_sum_test: Test the vector sum function in C and Torch
        - vq_block_test: Test the VQ block
"""
parser = argparse.ArgumentParser(description='Type of test to be performed')
parser.add_argument('test', type=str, help=parser_help, choices=['vector_sum', 'vq_block', 'matMul'])

# Parse the arguments
args = parser.parse_args()


__doc__ = r"""  

        This file contains several blocks to evaluate the inference mode of 
        Residual Vector Quantization (VQ).
        The VQ is a method to compress the input data by mapping it to a discrete set of values.
        It contains a core setting based on Euclidean distance or SinCos distance, and a set of 
        defined codewords where they are determined at the train mode.   
    """


N_ROW = 10
N_COL = 20


def distance_euclidean(x, embeds):

    xy = einsum('i d, j d -> i j', x, embeds)*-2
    x2 = reduce(x ** 2, 'i d -> i', 'sum')
    y2 = reduce(embeds ** 2, 'i d -> i', 'sum')
    print(x2.size(), y2.size())
    print(xy.size())
    return torch.sqrt(rearrange(x2, 'i -> i 1') + rearrange(y2, 'j -> 1 j') + xy)


def vector_sum(x_in ):
    x = reduce(x_in**2, 'i d -> i', 'sum')
    x_c = torch.sum(x_in**2, dim=1)
    return x, x_c


def matMul(x_in, y_in):
    x = einsum('i d, j d -> i j', x_in, y_in)*-2
    x_c = torch.mm(x_in, y_in.T)*-2
    return x, x_c


def vector_sum_test():
    
    x = torch.Tensor(np.arange(1, N_ROW*N_COL+1, 1))
    x = x.view(N_ROW, N_COL)
    x_res, x_c_res = vector_sum(x)
    print("Value Generated by the Vector Quantization Repo Code:")
    print(x_res)
    print("*"*10)
    print("The implemented version in C:")
    print(x_c_res)

def matMul_test():
    x = torch.Tensor(np.arange(1, N_ROW*N_COL+1, 1))
    x = x.view(N_ROW, N_COL)
    y = torch.Tensor(np.arange(1, N_ROW*N_COL+1, 1))
    y = y.view(N_COL, N_ROW)
    x_res, x_c_res = matMul(x, y)
    print("Value Generated by the Vector Quantization Repo Code:")
    print(x_res)
    print("*"*10)
    print("The implemented version in C:")
    print(x_c_res)

def vq_block_test(): 

    # Test the VQ block
    x = torch.randn(1, 128, 100)
    
    embeds = torch.load('codebooks.pt', map_location=torch.device('cpu'))
    
    # print the shapes
    print(f"Shape of the codebooks is {embeds.size()}")
    print(f"Shape of each codebook is {embeds[0].size()}")

    # distance_euclidean(x[0], embeds[0])
    dist = distance_euclidean(x[0], embeds[0])
    print(dist.size())
    print(dist.detach().numpy()) 
    # plot the distances 
    # with sns.plotting_context('poster'):
        # plt.figure(figsize=(16, 4))
        # plt.plot


if __name__ == "__main__":
    print(f"The selected test is {args.test}\n")
    if args.test == 'vq_block':
        vq_block_test()
    elif args.test == 'vector_sum':
        vector_sum_test()

    